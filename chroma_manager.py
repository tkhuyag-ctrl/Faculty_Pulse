import chromadb
import json
import uuid
from typing import List, Dict, Optional, Literal
from chromadb.config import Settings
from enum import Enum


class ContentType(Enum):
    """Enum for valid content types"""
    AWARD = "Award"
    PUBLICATION = "Publication"
    TALK = "Talk"


class ChromaDBManager:
    """Manager class for ChromaDB operations"""

    def __init__(self, persist_directory: str = "./chroma_db", collection_name: str = "faculty_pulse"):
        """
        Initialize ChromaDB client and collection

        Args:
            persist_directory: Directory to persist the database
            collection_name: Name of the collection to use
        """
        self.client = chromadb.PersistentClient(path=persist_directory)
        self.collection_name = collection_name
        self.collection = self.client.get_or_create_collection(
            name=collection_name,
            metadata={"hnsw:space": "cosine"}
        )

    def add_documents(self, documents: List[str], metadatas: List[Dict], ids: Optional[List[str]] = None):
        """
        Add documents to ChromaDB collection

        Args:
            documents: List of document texts
            metadatas: List of metadata dictionaries
            ids: Optional list of unique document IDs. If None, UUIDs will be autogenerated
        """
        # Generate UUIDs if no IDs provided
        if ids is None:
            ids = [str(uuid.uuid4()) for _ in range(len(documents))]

        self.collection.add(
            documents=documents,
            metadatas=metadatas,
            ids=ids
        )
        print(f"Successfully added {len(documents)} documents to collection '{self.collection_name}'")

    def add_submission_from_json(self, json_file_path: str):
        """
        Add a single submission from a JSON file

        Args:
            json_file_path: Path to JSON file with a single submission

        Expected JSON format:
        {
            "id": "sub_001",  # Optional - if omitted, Chroma will autogenerate a UUID
            "document": "Document content string",
            "metadata": {
                "faculty_name": "Dr. John Doe",
                "date_published": "2026-01-13T10:30:00Z",
                "content_type": "Award",
                "department": "Computer Science"
            }
        }
        """
        with open(json_file_path, 'r', encoding='utf-8') as f:
            submission = json.load(f)

        # Extract data from JSON
        document = submission['document']
        metadata = submission['metadata']
        submission_id = submission.get('id')

        # Call add_single_submission to handle the actual addition
        self.add_single_submission(
            document=document,
            faculty_name=metadata['faculty_name'],
            date_published=metadata['date_published'],
            content_type=metadata['content_type'],
            department=metadata['department'],
            submission_id=submission_id
        )

    def add_single_submission(
        self,
        document: str,
        faculty_name: str,
        date_published: str,
        content_type: str,
        department: str,
        submission_id: Optional[str] = None
    ):
        """
        Add a single submission to the collection

        Args:
            document: Document text content
            faculty_name: Name of the faculty member
            date_published: Publication date in ISO 8601 format (e.g., "2026-01-13T10:30:00Z")
            content_type: Type of content - must be "Award", "Publication", or "Talk"
            department: Department name
            submission_id: Optional unique submission ID. If None, a UUID will be autogenerated

        Raises:
            ValueError: If content_type is not valid
        """
        # Validate content_type
        valid_content_types = {ct.value for ct in ContentType}
        if content_type not in valid_content_types:
            raise ValueError(f"Invalid content_type '{content_type}'. Must be one of: {valid_content_types}")

        metadata = {
            "faculty_name": faculty_name,
            "date_published": date_published,
            "content_type": content_type,
            "department": department
        }

        # Generate UUID if no ID provided
        if submission_id is None:
            submission_id = str(uuid.uuid4())
            print(f"Successfully added submission with autogenerated ID '{submission_id}' to collection")
        else:
            print(f"Successfully added submission '{submission_id}' to collection")

        self.collection.add(
            documents=[document],
            metadatas=[metadata],
            ids=[submission_id]
        )

    def query_submissions(self, query_text: str, n_results: int = 5,
                         content_type: Optional[str] = None,
                         department: Optional[str] = None):
        """
        Query submissions from the collection

        Args:
            query_text: Query text
            n_results: Number of results to return
            content_type: Optional filter by content type (Award, Publication, Talk)
            department: Optional filter by department

        Returns:
            Query results
        """
        where_filter = {}

        if content_type:
            where_filter["content_type"] = content_type

        if department:
            where_filter["department"] = department

        query_kwargs = {
            "query_texts": [query_text],
            "n_results": n_results
        }

        if where_filter:
            query_kwargs["where"] = where_filter

        results = self.collection.query(**query_kwargs)
        return results

    def get_collection_count(self):
        """Get the number of documents in the collection"""
        return self.collection.count()

    def get_all_submissions(self):
        """
        Get all submissions from the collection

        Returns:
            Dictionary containing all documents, metadata, and IDs
        """
        count = self.collection.count()
        if count == 0:
            return {"ids": [], "documents": [], "metadatas": []}

        # Get all documents from the collection
        results = self.collection.get()
        return results

    def display_all_submissions(self):
        """
        Display all submissions in a readable format
        """
        results = self.get_all_submissions()

        if len(results['ids']) == 0:
            print("No submissions found in the database.")
            return

        print(f"\n{'='*80}")
        print(f"ALL SUBMISSIONS IN DATABASE (Total: {len(results['ids'])})")
        print(f"{'='*80}\n")

        for i, (doc_id, doc, metadata) in enumerate(zip(
            results['ids'],
            results['documents'],
            results['metadatas']
        ), 1):
            print(f"{i}. ID: {doc_id}")
            print(f"   Faculty: {metadata['faculty_name']}")
            print(f"   Department: {metadata['department']}")
            print(f"   Type: {metadata['content_type']}")
            print(f"   Date: {metadata['date_published']}")
            print(f"   Document: {doc}")
            print(f"   {'-'*76}\n")

    def delete_submission(self, submission_id: str):
        """Delete a submission by ID"""
        self.collection.delete(ids=[submission_id])
        print(f"Deleted submission '{submission_id}'")

    def clear_database(self):
        """
        Clear all submissions from the database

        Warning: This will permanently delete all data in the collection
        """
        count = self.collection.count()
        if count == 0:
            print("Database is already empty.")
            return

        # Delete the collection and recreate it
        self.client.delete_collection(name=self.collection_name)
        self.collection = self.client.get_or_create_collection(
            name=self.collection_name,
            metadata={"hnsw:space": "cosine"}
        )
        print(f"âœ“ Database cleared. Deleted {count} submission(s).")

    def update_submission(
        self,
        submission_id: str,
        document: str,
        faculty_name: str,
        date_published: str,
        content_type: str,
        department: str
    ):
        """
        Update an existing submission

        Args:
            submission_id: Unique submission ID
            document: Document text content
            faculty_name: Name of the faculty member
            date_published: Publication date in ISO 8601 format
            content_type: Type of content - must be "Award", "Publication", or "Talk"
            department: Department name

        Raises:
            ValueError: If content_type is not valid
        """
        # Validate content_type
        valid_content_types = {ct.value for ct in ContentType}
        if content_type not in valid_content_types:
            raise ValueError(f"Invalid content_type '{content_type}'. Must be one of: {valid_content_types}")

        metadata = {
            "faculty_name": faculty_name,
            "date_published": date_published,
            "content_type": content_type,
            "department": department
        }

        self.collection.update(
            ids=[submission_id],
            documents=[document],
            metadatas=[metadata]
        )
        print(f"Updated submission '{submission_id}'")


# Example usage
if __name__ == "__main__":
    """
    Simple example demonstrating basic usage.
    For comprehensive tests, run: python test_chroma_manager.py
    """
    print("ChromaDB Manager - Quick Example")
    print("-" * 40)

    # Initialize the manager
    manager = ChromaDBManager()

    # Add a submission with autogenerated ID
    print("\nAdding a submission...")
    manager.add_single_submission(
        document="Dr. Johnson received the Outstanding Research Award for contributions to machine learning.",
        faculty_name="Dr. Alice Johnson",
        date_published="2026-01-13T10:00:00Z",
        content_type="Award",
        department="Computer Science"
    )

    # Display all submissions
    print("\nAll submissions in database:")
    manager.display_all_submissions()

    print("\nFor comprehensive tests, run: python test_chroma_manager.py")
